<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20180531040147.1"><vh>Startup</vh>
<v t="ekr.20180530013340.1"><vh>@settings</vh>
<v t="ekr.20180530013345.1"><vh>@bool run-pyflakes-on-write = True</vh></v>
</v>
<v t="ekr.20180530194308.1"><vh>@button backup</vh></v>
</v>
<v t="vitalije.20180514144317.3"><vh>About this file (Vitalije)</vh></v>
<v t="ekr.20180531105447.1"><vh>About this file (EKR)</vh></v>
<v t="vitalije.20180515102254.1"><vh>@file box_images.py</vh></v>
<v t="vitalije.20180510154246.1"><vh>@file test_leo_data_model.py</vh></v>
<v t="vitalije.20180510153405.1"><vh>@file leoDataModel.py</vh></v>
<v t="ekr.20180531050445.1"><vh>** To do</vh></v>
<v t="ekr.20180531204621.1"><vh>Recent</vh>
<v t="ekr.20180531210200.1"><vh> unused self.test code from class LeoTreeModel</vh></v>
<v t="vitalije.20180518115534.1"><vh> unused &lt;&lt; define draw_loop &gt;&gt;</vh></v>
<v t="ekr.20180530112119.1"><vh>Contain implicit sections</vh>
<v t="vitalije.20180516132431.1"><vh>promote (changed)</vh>
<v t="vitalije.20180517160150.1"><vh>1. promote this part of outline</vh></v>
<v t="vitalije.20180517160237.1"><vh>2. update clones of this node in outline</vh></v>
<v t="vitalije.20180517160615.1"><vh>3. update sizes in outline</vh></v>
</v>
<v t="vitalije.20180516141710.1"><vh>promote_children (changed)</vh>
<v t="vitalije.20180517171517.1"><vh>1. reduce levels</vh></v>
<v t="vitalije.20180517171551.1"><vh>2. iterate over direct children</vh></v>
<v t="vitalije.20180517171628.1"><vh>3. set size to 1</vh></v>
<v t="vitalije.20180517171705.1"><vh>4. process standalone clones of this node</vh></v>
</v>
<v t="vitalije.20180517172602.1"><vh>indent_node (changed)</vh>
<v t="vitalije.20180517172756.1"><vh>1. increase levels</vh></v>
<v t="vitalije.20180517172946.1"><vh>2. link to new parent</vh></v>
<v t="vitalije.20180517173423.1"><vh>3. process clones of new parent</vh>
<v t="vitalije.20180517181545.1"><vh>3.1 update sizes</vh></v>
<v t="vitalije.20180517181729.1"><vh>3.2 prepare data for insertion</vh></v>
<v t="vitalije.20180517181737.1"><vh>3.3 insert data</vh></v>
</v>
</v>
</v>
<v t="ekr.20180531204401.1"><vh>Contains cProfile</vh>
<v t="ekr.20180530110731.1"><vh>loadex (collects stats)</vh></v>
<v t="ekr.20180531160419.1"><vh>traverse_speed (changed)</vh></v>
</v>
<v t="ekr.20180530191635.1"><vh>load stats</vh></v>
<v t="ekr.20180531204548.1"><vh>most important: load file</vh>
<v t="vitalije.20180510103732.1"><vh>load_derived_file</vh>
<v t="vitalije.20180510103732.2"><vh>&lt;&lt; scan header, setting first_lines &amp; delims &gt;&gt;</vh></v>
<v t="ekr.20180531102239.1"><vh>&lt;&lt; define get_patterns &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.5"><vh>&lt;&lt; handle the top node &gt;&gt;</vh>
<v t="vitalije.20180510103732.6"><vh>&lt;&lt; define nodes bunch &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.7"><vh>&lt;&lt; define set_node &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.9"><vh>&lt;&lt; start top node &gt;&gt;</vh></v>
</v>
<v t="vitalije.20180510103732.10"><vh>&lt;&lt; iterate all other lines &gt;&gt;</vh>
<v t="ekr.20180531102949.1"><vh>&lt;&lt; init the grand iteration &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.11"><vh>&lt;&lt; handle verbatim lines &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.12"><vh>&lt;&lt; unindent the line if necessary &gt;&gt;</vh></v>
<v t="ekr.20180531122608.1"><vh>&lt;&lt; short-circuit later tests &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.13"><vh>&lt;&lt; handle @all &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.14"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.15"><vh>&lt;&lt; handle start of @doc parts &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.16"><vh>&lt;&lt; handle start of @code parts &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.21"><vh>&lt;&lt; handle in_doc &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.17"><vh>&lt;&lt; handle section refs &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.18"><vh>&lt;&lt; handle node_start &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.19"><vh>&lt;&lt; handle @-leo &gt;&gt;</vh></v>
<v t="vitalije.20180510103732.20"><vh>&lt;&lt; handle directives &gt;&gt;</vh></v>
</v>
<v t="vitalije.20180510103732.22"><vh>&lt;&lt; yield all nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20180529183702.1"><vh>viter (ltm_from_derived_file)</vh></v>
<v t="vitalije.20180510103732.7"></v>
<v t="ekr.20180530192200.1"><vh>--- most called</vh></v>
<v t="vitalije.20180510153747.1"><vh>parPosIter</vh></v>
<v t="vitalije.20180510153738.2"><vh>parents</vh></v>
<v t="vitalije.20180510194736.1"><vh>replaceNode &amp; updateParentSize</vh></v>
</v>
<v t="ekr.20180531162551.1"><vh>traverse stats</vh></v>
<v t="ekr.20180531204503.1"><vh>----- traversal</vh>
<v t="vitalije.20180515103828.1"><vh>draw_tree</vh></v>
<v t="vitalije.20180515122209.1"><vh>display_items</vh></v>
<v t="vitalije.20180516131800.1"><vh>topIndex_write</vh></v>
</v>
</v>
<v t="vitalije.20180514194301.1"
expanded="vitalije.20180514223632.1,vitalije.20180518115038.1,"><vh>@file miniTkLeo.py</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20180529183702.1">def viter():
    stack = [None for i in range(256)]
    lev0 = 0
    for gnx, h, b, lev in load_derived_file(lines):
        ps = parents[gnx] # parents is a defaultdict(list)
            # ps: parents
        cn = []
            # cn: children
        s = [1]
            # s: size, of some kind.
        stack[lev] = [gnx, h, b, lev, s, ps, cn]
            #         0,   1, 2, 3,   4, 5,  6
        if lev:
            # add parent gnx to list of parents
            ps.append(stack[lev - 1][0])
            if lev &gt; lev0:
                # parent level is lev0
                # add this gnx to list of children in parent
                stack[lev0][6].append(gnx)
            else:
                # parent level is one above 
                # add this gnx to list of children in parent
                stack[lev - 1][6].append(gnx)
        lev0 = lev
        # increase size of every node in current stack
        for z in stack[:lev]:
            z[4][0] += 1
        # finally yield this node
        yield stack[lev]
</t>
<t tx="ekr.20180530013340.1"></t>
<t tx="ekr.20180530013345.1">
</t>
<t tx="ekr.20180530110731.1">def loadex():
    '''The target of threading.Thread.'''
    if profile_load: # Profile the code.
        cProfile.runctx('loadex_helper()',
            globals(),
            locals(),
            'profile_stats', # 'profile-%s.out' % process_name
        )
        print('===== writing profile_stats')
        p = pstats.Stats('profile_stats')
        p.strip_dirs().sort_stats('tottime').print_stats(50)
            # .print_stats('leoDataModel.py', 50)
    else:
        loadex_helper()
    
def loadex_helper():
    ltm2 = LeoTreeModel.frombytes(ltmbytes)
    loaddir = os.path.dirname(fname)
    loadExternalFiles(ltm2, loaddir)
    G.q.put(ltm2)
</t>
<t tx="ekr.20180530112119.1"></t>
<t tx="ekr.20180530191635.1">Without stats: 0.6 to 0.7 sec.
With stats: 0.9 sec.

1. Limited to leoDataModel.py:

Tottime:
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 8212    0.267    0.000    0.586    0.000  leoDataModel.py:1233(load_derived_file)
 8212    0.023    0.000    0.611    0.000  leoDataModel.py:1569(viter)
 8047    0.017    0.000    0.024    0.000  leoDataModel.py:1327(set_node)

Calls:
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
16691    0.003    0.000    0.006    0.000  leoDataModel.py:37(parPosIter)
 8212    0.268    0.000    0.587    0.000  leoDataModel.py:1233(load_derived_file)
 8212    0.023    0.000    0.612    0.000  leoDataModel.py:1569(viter)
 8047    0.017    0.000    0.023    0.000  leoDataModel.py:1327(set_node)
  971    0.000    0.000    0.001    0.000  leoDataModel.py:293(parents)
806/165  0.001    0.000    0.001    0.000  leoDataModel.py:412(updateParentSize) (in replaceNode)

2. Including all methods:
    
TotTime:
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 8212    0.272    0.000    0.594    0.000  leoDataModel.py:1233(load_derived_file)
626060   0.220    0.000    0.220    0.000  {method 'match' of '_sre.SRE_Pattern' objects}
232802   0.036    0.000    0.036    0.000  {method 'startswith' of 'str' objects}
 165     0.021    0.000    0.030    0.000  {method 'read' of '_io.TextIOWrapper' objects}
     
Calls:
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
626060   0.221    0.000    0.221    0.000  {method 'match' of '_sre.SRE_Pattern' objects}
232802   0.036    0.000    0.036    0.000  {method 'startswith' of 'str' objects}
167416   0.014    0.000    0.014    0.000  {method 'append' of 'list' objects}
110420   0.008    0.000    0.008    0.000  {built-in method builtins.len}
95453    0.007    0.000    0.007    0.000  {method 'isspace' of 'str' objects}
35554    0.006    0.000    0.006    0.000  {method 'group' of '_sre.SRE_Match' objects}
16357    0.001    0.000    0.001    0.000  {method 'random' of '_random.Random' objects}
 8906    0.002    0.000    0.002    0.000  {method 'pop' of 'list' objects}
 8562    0.006    0.000    0.006    0.000  {method 'join' of 'str' objects}
 2204    0.000    0.000    0.000    0.000  {built-in method builtins.isinstance}

</t>
<t tx="ekr.20180530192200.1"></t>
<t tx="ekr.20180530194308.1">c.backup_helper(
    base_dir='c:/Users/edreamleo/backup',
        # 'C:/leo.repo/LeoModel',
    env_key=None, # 'LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=False,
)
</t>
<t tx="ekr.20180531040147.1"></t>
<t tx="ekr.20180531050445.1">@language rest
@wrap

- Investigate drawing performance using existing vnodes, using the Leo bridge.
- Investigate compatibility with existing vnodes.
</t>
<t tx="ekr.20180531102239.1">def get_patterns(delim_st, delim_en):
    '''
    Create regex patterns based on the given comment delims.
    There is zero cost to making this a function.
    '''
    if delim_en:
        dlms = re.escape(delim_st), re.escape(delim_en)
        # Plain...
        code_src = r'^%s@@c(ode)?%s$'%dlms
        doc_src = r'^%s@\+(at|doc)?(\s.*?)?%s$'%dlms
        ns_src = r'^(\s*)%s@\+node:([^:]+): \*(\d+)?(\*?) (.*?)%s$'%dlms
        sec_src = r'^(\s*)%s@(\+|-)&lt;{2}[^&gt;]+&gt;&gt;(.*?)%s$'%dlms
        # DOTALL..
        all_src = r'^(\s*)%s@(\+|-)all%s\s*$'%dlms
        oth_src = r'^(\s*)%s@(\+|-)others%s\s*$'%dlms
    else:
        dlms = re.escape(delim_st)
        all_src = r'^(\s*)%s@(\+|-)all\s*$'%dlms
        code_src = r'^%s@@c(ode)?$'%dlms
        doc_src = r'^%s@\+(at|doc)?(\s.*?)?'%dlms + '\n'
        ns_src = r'^(\s*)%s@\+node:([^:]+): \*(\d+)?(\*?) (.*)$'%dlms
        oth_src = r'^(\s*)%s@(\+|-)others\s*$'%dlms
        sec_src = r'^(\s*)%s@(\+|-)&lt;{2}[^&gt;]+&gt;&gt;(.*)$'%dlms
    ### union_src = '|'.join([code_src, doc_src, ns_src, sec_src])
    ### union2_src = '|'.join([all_src, oth_src])
    return bunch(
        all        = re.compile(all_src, re.DOTALL),
        code       = re.compile(code_src),
        doc        = re.compile(doc_src),
        node_start = re.compile(ns_src),
        others     = re.compile(oth_src, re.DOTALL),
        section    = re.compile(sec_src),
        ### union      = re.compile(union_src),
        ### union2     = re.compile(union2_src, re.DOTALL),
    )
</t>
<t tx="ekr.20180531102949.1">stack = []
    # Entries are (gnx, indent)
    # Updated when at+others, at+&lt;section&gt;, or at+all is seen.
in_all = False
    # True: in @all.
in_doc = False
    # True: in @doc parts.
verbline = delim_st + '@verbatim' + delim_en + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
start = 2 * len(first_lines) + 2
    # Skip twice the number of first_lines, one header line, and one top node line
indent = 0 
    # The current indentation.
gnx = topgnx
    # The node that we are reading.
body = nodes.body[gnx]
    # list of lines for current node.
# dereference the patterns
all_pat = patterns.all
code_pat = patterns.code
doc_pat = patterns.doc
node_start_pat = patterns.node_start
others_pat = patterns.others
section_pat = patterns.section
</t>
<t tx="ekr.20180531105447.1">@language rest
@wrap

May 31, 2018: This file contains various changes to Vitalije's original files:

The "Recent" nodes contains various experiments and data.

The major changes:

- Added profiling code to "loadex (collects stats)".
- Use explicit sections in load_derived_files.
  The resulting code should be almost exactly the same,
  but the explicit sections help a lot.

Smallish changes:

- The node "class LeoTreeModel" contains some failed profiling experiments.
- Replaced the ivars() method with the pickled_vars ivar, used only by tobytes().
  This is safe because of pyflakes checks.
- Removed a redundant definition of class bunch.

Test failure:

test_leo_data_model fails for my local copy of leoPy.leo:

TEST FAILED
FAIL parent/child 1('ekr.20160921220517.1', 'ekr.20160921210529.1')

(5, 'ekr.20160921220517.1', 'goto.is_visible_sentinel', 'd41d8cd98f00b204e9800998ecf8427e', False)
(5, 'ekr.20160921210529.1', 'goto.find_node_start', '4593f464016d9b40686ed7dd7b913386', False)
</t>
<t tx="ekr.20180531122608.1"># This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches delim_st + '@'   
if not in_doc and not line.strip().startswith(delim_st+'@'):
    body.append(line)
    continue
</t>
<t tx="ekr.20180531160419.1">def traverse_speed(x):
    '''Traverse the entire tree.'''
    g.cls()
    if profile_redraw:
        cProfile.runctx('traverse_speed_helper()',
            globals(),
            locals(),
            'profile_stats', # 'profile-%s.out' % process_name
        )
        print('===== starting profile_stats')
        p = pstats.Stats('profile_stats')
        p.sort_stats('ncalls').print_stats(100)
            # p.strip_dirs().
            # .print_stats('leoDataModel.py', 50)
    else:
        traverse_speed_helper()
        
def traverse_speed_helper():
        
    ltm.selectedPosition = ltm.positions[1]
    ltm.expanded.clear()
    ltm.invalidate_visual()
    draw_tree(tree, ltm)

    def tf(i):
        if 1:
            n_positions = len(ltm.positions)
            n = min(1000, n_positions)
            for i in range(n):
                # From alt_right:
                bw = G.body
                gnx = ltm.select_node_right()
                if gnx:
                    body = ltm.attrs[gnx][1]
                    bw.replace('1.0', 'end', body)
                draw_tree(tree, ltm)
            print('===== writing profile_stats')
            p = pstats.Stats('profile_stats')
            p.strip_dirs().sort_stats('tottime').print_stats(50)
                # .print_stats('leoDataModel.py', 50)
        else:
            alt_right(None)
            if i &lt; 500 and i &lt; n_positions:
                tree.after_idle(tf, i + 1)
        dt = datetime.datetime.utcnow() - t1
        t = dt.seconds + 1e-6*dt.microseconds
        G.log.insert('end -1 ch', '%s iterations in %6.2f sec\n'%(n,t))

    t1 = datetime.datetime.utcnow()
    tf(1)

G.app.bind_all('&lt;Shift-F10&gt;', traverse_speed)
</t>
<t tx="ekr.20180531162551.1">TotTime:
    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      2001    0.162    0.000    1.995    0.001 miniTkLeo.py:302(draw_loop)
     30005    0.074    0.000    0.091    0.000 leoDataModel.py:482(display_items)
----------
    159149    1.225    0.000    1.751    0.000 {method 'call' of '_tkinter.tkapp' objects}
     64080    0.118    0.000    0.174    0.000 tkinter\__init__.py:1309(_options)
     64062    0.108    0.000    1.065    0.000 tkinter\__init__.py:1460(_configure)
    128142    0.098    0.000    0.154    0.000 tkinter\__init__.py:93(_cnfmerge)
     84021    0.094    0.000    0.629    0.000 tkinter\__init__.py:2458(coords)
    348928    0.054    0.000    0.054    0.000 {built-in method builtins.isinstance}
     64062    0.034    0.000    1.099    0.000 tkinter\__init__.py:2565(itemconfigure)
     86022    0.032    0.000    0.032    0.000 {method 'splitlist' of '_tkinter.tkapp' objects}
    128160    0.026    0.000    0.026    0.000 {built-in method _tkinter._flatten}
      4001    0.024    0.000    0.024    0.000 {method 'index' of 'list' objects}
     17047    0.017    0.000    0.017    0.000 {method 'getint' of '_tkinter.tkapp' objects}
     64098    0.016    0.000    0.016    0.000 {method 'update' of 'dict' objects}
     84021    0.013    0.000    0.013    0.000 tkinter\__init__.py:2461(&lt;listcomp&gt;)
      1000    0.012    0.000    0.046    0.000 tkinter\__init__.py:1382(_substitute)
  
NCalls:
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    30005    0.074    0.000    0.091    0.000 leoDataModel.py:482(display_items)
     4001    0.002    0.000    0.026    0.000 leoDataModel.py:312(selectedIndex)
     3000    0.004    0.000    1.187    0.001 miniTkLeo.py:452(proxycmd)
     2001    0.162    0.000    2.006    0.001 miniTkLeo.py:302(draw_loop)
     2001    0.008    0.000    2.045    0.001 miniTkLeo.py:290(draw_tree)
     2001    0.003    0.000    0.012    0.000 miniTkLeo.py:469(rows_count)
----------
   348928    0.054    0.000    0.054    0.000 {built-in method builtins.isinstance}
   159149    1.234    0.000    1.764    0.000 {method 'call' of '_tkinter.tkapp' objects}
   128160    0.026    0.000    0.026    0.000 {built-in method _tkinter._flatten}
   128142    0.099    0.000    0.155    0.000 tkinter\__init__.py:93(_cnfmerge)
    92088    0.008    0.000    0.008    0.000 {built-in method builtins.callable}
    86022    0.032    0.000    0.032    0.000 {method 'splitlist' of '_tkinter.tkapp' objects}
    84021    0.094    0.000    0.633    0.000 tkinter\__init__.py:2458(coords)
    84021    0.013    0.000    0.013    0.000 tkinter\__init__.py:2461(&lt;listcomp&gt;)
    65191    0.008    0.000    0.008    0.000 {method 'items' of 'dict' objects}
    64098    0.015    0.000    0.015    0.000 {method 'update' of 'dict' objects}
    64080    0.118    0.000    0.175    0.000 tkinter\__init__.py:1309(_options)
    64062    0.033    0.000    1.105    0.000 tkinter\__init__.py:2565(itemconfigure)
    64062    0.111    0.000    1.072    0.000 tkinter\__init__.py:1460(_configure)
    63854    0.007    0.000    0.007    0.000 {built-in method builtins.len}
    36074    0.006    0.000    0.006    0.000 tkinter\__init__.py:3497(__str__)
    28004    0.006    0.000    0.006    0.000 {built-in method builtins.getattr}
    17047    0.017    0.000    0.017    0.000 {method 'getint' of '_tkinter.tkapp' objects}
    11000    0.005    0.000    0.018    0.000 tkinter\__init__.py:1388(getint_event)
     4001    0.024    0.000    0.024    0.000 {method 'index' of 'list' objects}
     2001    0.002    0.000    0.002    0.000 {built-in method builtins.max}
</t>
<t tx="ekr.20180531204401.1"></t>
<t tx="ekr.20180531204503.1">@language rest
@wrap

Only draw_loop and display_items contribute significant time:
    
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  2001    0.162    0.000    1.995    0.001 miniTkLeo.py:302(draw_loop)
 30005    0.074    0.000    0.091    0.000 leoDataModel.py:482(display_items)

@language python
</t>
<t tx="ekr.20180531204548.1"></t>
<t tx="ekr.20180531204621.1"></t>
<t tx="ekr.20180531210200.1">TEST = False
                
if TEST:
                
    def __setattr__(self, attr, val):
        # First, set that ivar.
        self.__dict__[attr] = val
        # Next, update the stats.
        d = self.__dict__['callers'] ### .get('callers')
        if 1:
            caller = '::'+attr
        else:
            caller = g.callers(2)+'::'+attr
        d [caller] += 1
             
    def __getattr__(self, attr):
        # Only called for missing attributes
        if 1:
            callers = ':'+attr
        else:
            callers = g.callers(2)+':'+attr
        self.callers[callers] += 1
        self.stats[attr] += 1
        return getattr(self, '_'+attr)
        
    # From the ctor:
        
        self.callers = defaultdict(int)
        self.stats = defaultdict(int)
        
        if self.TEST:
            self._positions = []
            self._nodes = []
            self._attrs = {}
            self._levels = []
            self._parPos = []
            self._expanded = set()
            self._marked = set()
            self._selectedPosition = None
            self._gnx2pos = defaultdict(list)
        else:
            self.positions = []
            self.nodes = []
            self.attrs = {}
            self.levels = []
            self.parPos = []
            self.expanded = set()
            self.marked = set()
            self.selectedPosition = None
            self.gnx2pos = defaultdict(list)</t>
<t tx="vitalije.20180510103732.1">def load_derived_file(lines):
    '''A generator yielding tuples: (gnx, h, b, level).'''
    # pylint: disable=no-member
    flines = tuple(enumerate(lines))
    &lt;&lt; scan header, setting first_lines &amp; delims &gt;&gt;
    &lt;&lt; define get_patterns &gt;&gt;
    patterns = get_patterns(delim_st, delim_en)
    &lt;&lt; handle the top node &gt;&gt;
    &lt;&lt; iterate all other lines &gt;&gt;
    &lt;&lt; yield all nodes &gt;&gt;
</t>
<t tx="vitalije.20180510103732.10"># Append lines to body, changing nodes as necessary.
&lt;&lt; init the grand iteration &gt;&gt;
for i, line in flines[start:]:
    # These three sections must be first.
    &lt;&lt; handle verbatim lines &gt;&gt;
    &lt;&lt; unindent the line if necessary &gt;&gt;
    &lt;&lt; short-circuit later tests &gt;&gt;
    # The order of these sections does matter.
    &lt;&lt; handle @all &gt;&gt;
    &lt;&lt; handle @others &gt;&gt;
    &lt;&lt; handle start of @doc parts &gt;&gt;
    &lt;&lt; handle start of @code parts &gt;&gt;
    &lt;&lt; handle section refs &gt;&gt;
    &lt;&lt; handle node_start &gt;&gt;
    &lt;&lt; handle @-leo &gt;&gt;
    &lt;&lt; handle directives &gt;&gt;
    &lt;&lt; handle in_doc &gt;&gt; # Apparently, must be last.
    # A normal line.
    body.append(line)
# Handle @last lines.
if i + 1 &lt; len(flines):
    nodes.body[topgnx].extend('@last %s'%x for x in flines[i+1:])
</t>
<t tx="vitalije.20180510103732.11">if verbatim:
    # Previous line was verbatim sentinel. Append this line as it is.
    body.append(line)
    verbatim = False # next line should be normally processed.
    continue
if line == verbline:
    # This line is verbatim sentinel, next line should be appended as it is
    verbatim = True
    continue
</t>
<t tx="vitalije.20180510103732.12"># is indent still valid?
if indent and line[:indent].isspace() and len(line) &gt; indent:
    # yes? let's strip unnecessary indentation
    line = line[indent:]
</t>
<t tx="vitalije.20180510103732.13">m = all_pat.match(line)
if m:
    in_all = m.group(2) == '+' # is it opening or closing sentinel
    if in_all:
        # opening sentinel
        body.append('@all\n')
        # keep track which node should we continue to build
        # once we encounter closing at-all sentinel
        stack.append((gnx, indent))
    else:
        # this is closing sentinel
        # let's restore node where we started at-all directive
        gnx, indent = stack.pop()
        # restore body which should receive next lines
        body = nodes.body[gnx]
    continue
</t>
<t tx="vitalije.20180510103732.14">m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+': # is it opening or closing sentinel
        # opening sentinel
        body.append(m.group(1) + '@others\n')
        # keep track which node should we continue to build
        # once we encounter closing at-others sentinel
        stack.append((gnx, indent))
        indent += m.end(1) # adjust current identation
    else:
        # this is closing sentinel
        # let's restore node where we started at-others directive
        gnx, indent = stack.pop()
        # restore body which should receive next lines
        body = nodes.body[gnx]
    continue

</t>
<t tx="vitalije.20180510103732.15">if not in_doc:
    # This guard ensures that the short-circuit tests are valid.
    m = doc_pat.match(line)
    if m:
        # yes we are at the beginning of doc part
        # was it @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or '' # is there any text on first line?
        if doc2:
            # start doc part with some text on the same line
            body.append('%s%s\n'%(doc, doc2))
        else:
            # no it is only directive on this line
            body.append(doc + '\n')
        # following lines are part of doc block
        in_doc = True
        continue
</t>
<t tx="vitalije.20180510103732.16">if in_doc:
    # when using both delimiters, doc block starts with first delimiter
    # alone on line and at the end of doc block end delimiter is also
    # alone on line. Both of this lines should be skipped
    if line in doc_skip:
        continue
    #
    # maybe this line ends doc part and starts code part?
    m = code_pat.match(line)
    if m:
        # yes, this line is at-c or at-code line
        in_doc = False  # stop building doc part
        # append directive line
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
</t>
<t tx="vitalije.20180510103732.17">m = section_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+': # is it opening or closing sentinel
        # opening sentinel
        ii = m.end(2) # before &lt;&lt;
        jj = m.end(3) # at the end of line
        body.append(m.group(1) + line[ii:jj] + '\n')
        # keep track which node should we continue to build
        # once we encounter closing at-&lt;&lt; sentinel
        stack.append((gnx, indent))
        indent += m.end(1) # adjust current identation
    else:
        # this is closing sentinel
        # Restore node where we started at+&lt;&lt; directive
        gnx, indent = stack.pop()
        # Restore body which should receive next lines
        body = nodes.body[gnx]
    continue
</t>
<t tx="vitalije.20180510103732.18">m = node_start_pat.match(line)
if m:
    in_doc = False
    gnx = set_node(m)
    if len(nodes.level[gnx]) &gt; 1:
        # clone in at-all
        # let it collect lines in throwaway list
        body = []
    else:
        body = nodes.body[gnx]
    continue
</t>
<t tx="vitalije.20180510103732.19">if line.startswith(delim_st + '@-leo'):
    break
</t>
<t tx="vitalije.20180510103732.2">@
   Find beginning of top (root node) of this derived file.
   We expect zero or more first lines before leo header line.

   Leo header line will give usefull information such as delimiters.
@c
header_pattern = re.compile(r'''
    ^(.+)@\+leo
    (-ver=(\d+))?
    (-thin)?
    (-encoding=(.*)(\.))?
    (.*)$''', re.VERBOSE)
#
# Scan for the header line, which follows any @first lines.
first_lines = []
for i, line in flines:
    m = header_pattern.match(line)
    if m:
        break
    first_lines.append(line)
else:
    raise ValueError('wrong format, not derived file')
#
# Set the delims.
# m.groups example ('#', '-ver=5', '5', '-thin', None, None, None, '')
delim_st = m.group(1)
delim_en = m.group(8)
</t>
<t tx="vitalije.20180510103732.20">if line.startswith(delim_st + '@@'):
    ii = len(delim_st) + 1 # on second '@'
    # strip delim_en if it is set or just '\n'
    jj = line.rfind(delim_en) if delim_en else -1
    # append directive line
    body.append(line[ii:jj] + '\n')
    continue
</t>
<t tx="vitalije.20180510103732.21">if in_doc and not delim_en:
    # when using just one delimiter (start)
    # doc lines start with delimiter + ' '
    body.append(line[len(delim_st)+1:])
    continue
#
# when delim_en is not '', doc part starts with one start delimiter and \n
# and ends with end delimiter followed by \n
# in that case doc lines are unchcanged
</t>
<t tx="vitalije.20180510103732.22">for gnx in nodes.gnxes:
    b = ''.join(nodes.body[gnx])
    h = nodes.head[gnx]
    lev = nodes.level[gnx].pop(0)
    yield gnx, h, b, lev-1
</t>
<t tx="vitalije.20180510103732.5">&lt;&lt; define nodes bunch &gt;&gt;
&lt;&lt; define set_node &gt;&gt;
@
If the cloing comment delim, delim_en, exists
then doc parts start with delim_st alone on line
and doc parts end with delim_en alone on line

so whenever we encounter any of this lines, 
we have just to skip and nothing should be added to body.
@c
doc_skip = (delim_st + '\n', delim_en + '\n')
&lt;&lt; start top node &gt;&gt;
</t>
<t tx="vitalije.20180510103732.6"># This bunch collects all input during the scan of input lines.
nodes = bunch(
    level = defaultdict(list),
        # Keys are gnx's. Values are lists of node levels, in input order.
        # This is to support at-all directive which will write clones several times.
    head = {},
        # Keys are gnx's, values are the node's headline.
    body = defaultdict(list),
        # Keys are gnx's, values are list of body lines.
    gnxes = [],
        # A list of gnx, in the order in which they will be yielded.
)
</t>
<t tx="vitalije.20180510103732.7">@ utility function to set data from regex match object from sentinel line
  see node_start pattern. groups[1 - 5] are:
  (indent, gnx, level-number, second star, headline)
      1      2         3            4          5
  returns gnx
@c
def set_node(m):
    gnx = m.group(2)
    lev = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
    nodes.level[gnx].append(lev)
    nodes.head[gnx] = m.group(5)
    nodes.gnxes.append(gnx)
    return gnx
</t>
<t tx="vitalije.20180510103732.9">topnodeline = flines[len(first_lines) + 1][1] # line after header line
m = patterns.node_start.match(topnodeline)
topgnx = set_node(m)
#
# append first lines if we have some
nodes.body[topgnx] = ['@first '+ x for x in first_lines]
assert topgnx, 'top node line [%s] %d first lines'%(topnodeline, len(first_lines))
</t>
<t tx="vitalije.20180510153738.2">def parents(self, gnx):
    '''Returns list of gnxes of parents of node with given gnx'''
    a = self.attrs.get(gnx)
    return a[2] if a else []

</t>
<t tx="vitalije.20180510153747.1">def parPosIter(ps, levs):
    '''Helper iterator for parent positions. Given sequence of
       positions and corresponding levels it generates sequence
       of parent positions'''
    rootpos = ps[0]
    levPars = [rootpos for i in range(256)] # max depth 255 levels
    it = zip(ps, levs)
    next(it) # skip first root node which has no parent
    yield rootpos
    for p, l in it:
        levPars[l] = p
        yield levPars[l - 1]

</t>
<t tx="vitalije.20180510194736.1">def replaceNode(self, t2):
    '''Replaces node with given subtree. This outline must contain
       node with the same gnx as root gnx of t2.'''
    t1 = self

    gnx = t2.nodes[0]
    sz0 = t1.attrs[gnx][4]

    # this function replaces one instance of given node
    def insOne(i):
        l0 = t1.levels[i]
        npos = [random.random() for x in t2.nodes]
        npos[0] = t1.positions[i]
        ppos = t1.parPos[i]
        t1.parPos[i:i+sz0] = list(parPosIter(npos, t2.levels))
        t1.parPos[i] = ppos
        t1.positions[i:i+sz0] = npos
        t1.nodes[i:i+sz0] = t2.nodes
        t1.levels[i:i+sz0] = [(l0 + x) for x in t2.levels]
        for p, gnx in zip(npos[1:], t2.nodes[1:]):
            t1.gnx2pos[gnx].append(p)
    # difference in sizes between old node and new node
    dsz = len(t2.positions) - sz0
    # parents of this node must be preserved
    t2.attrs[gnx][2] = t1.parents(gnx)
    for pi in t1.gnx2pos[gnx]:
        i = t1.positions.index(pi)
        insOne(i)
    # some of nodes in t2 may be clones of nodes in t1
    # they will have some parents that are outside t2
    # therefore it is necessary for these nodes in t2 to
    # update their parents list by adding only those parents
    # that are not part of t2.
    t2gnx = set(t2.nodes)
    for x in t2gnx:
        if x not in t1.attrs:continue
        if x is t2.nodes[0]:continue
        ps = t1.attrs[x][2]
        t2.attrs[x][2].extend([y for y in ps if y not in t2gnx])
    # now we can safely update attrs dict of t1
    t1.attrs.update(t2.attrs)
    # one last task is to update size in all ancestors of replaced node
    def updateParentSize(gnx):
        for pgnx in t1.parents(gnx):
            t1.attrs[pgnx][4] += dsz
            updateParentSize(pgnx)
    updateParentSize(gnx)
</t>
<t tx="vitalije.20180514144317.3">@language rest
@wrap

This file contains several python files:
    - leoDataModel.py
    - miniTkLeo.py
    - test_leo_data_model.py

To run test_leo_data_model.py use following command:

python test_leo_data_model.py &lt;path to Leo&gt;


Script do not depend on Leo modules, it just uses Leo
files as data for testing new LeoTreeModel class.


miniTkLeo is a minimal Tk application that shows the outline.
It allows user:

    - to change the content of any node, by typing

    - to reshape the outline by moving nodes around
      (left, right, up and down, promote/demote)

New info: May 29. 2018.
test_leo_data.py contains some tests that import all source files from
the python installed modules. Those tests rely on file paths to the
installation of python. Before executing test_leo_data check and adjust
file paths to match your instalation or any other folder you may be
interested to check.

</t>
<t tx="vitalije.20180515103828.1">def draw_tree(canv, ltm):
    '''Redraw the entire visible part of the tree.'''
    HR = 24 # pixels/per row
    LW = 2 * HR
    count = rows_count(HR)
        # The number of rows.
    items = list(canv.find('all'))
    if len(items) &lt; 1:
        # add selection highliter the first time we draw the tree.
        items.append(
            canv.create_rectangle((0, -100, 300, -100+HR), 
            fill='#77cccc'))
    #
    # The main drawing loop.
    # Each row consists of 3 items: the checkbox, icon and text.
    #
    i = 1 # The global row.
    for j, dd in enumerate(ltm.display_items(skip=G.topIndex.get(), count=count)):
        p, gnx, h, lev, pm, iconVal, sel = dd
            # The tuples yielded from display_items.
        plusMinusIcon = getattr(G.icons, pm)
        #
        # Update the counts &amp; x,y offsets.
        i = j * 3 + 1
        x = lev * LW - 20
        y = j * HR + HR + 2
        #
        # Set the color
        if sel:
            canv.coords(items[0], 0, y - HR/2 - 2, canv.winfo_width(), y + HR/2 + 2)
            fg = '#000000'
        else:
            fg = '#a0a070'
        #
        # Update or add this item.
        if i + 2 &lt; len(items):
            # The row exists.  Update the 3 items.
            if plusMinusIcon:
                canv.itemconfigure(items[i], image=plusMinusIcon)
                canv.coords(items[i], x, y)
            else:
                canv.coords(items[i], -200, y)
            canv.itemconfigure(items[i + 1], image=G.boxes[iconVal])
            canv.coords(items[i + 1], x + 20, y)
            canv.itemconfigure(items[i + 2], text=h, fill=fg)
            canv.coords(items[i + 2], x + 40, y)
        else:
            # Add 3 more items to canvas.
            items.append(canv.create_image(x, y, image=plusMinusIcon))
            items.append(canv.create_image(x + 20, y, image=G.boxes[iconVal]))
            items.append(canv.create_text(x + 40, y, text=h, anchor="w", fill=fg))
            # Bind clicks to click handlers.
            canv.tag_bind(items[i], '&lt;Button-1&gt;', click_pmicon(j), add=False)
            canv.tag_bind(items[i + 1], '&lt;Button-1&gt;', click_h(j), add=False)
            canv.tag_bind(items[i + 2], '&lt;Button-1&gt;', click_h(j), add=False)
    # Hide any extra item on canvas 
    for item in items[i + 3:]:
        canv.coords(item, 0, -200)
</t>
<t tx="vitalije.20180515122209.1">def display_items(self, skip=0, count=None):
    '''
    A generator yielding tuples for visible, non-skipped items:
    
    (pos, gnx, h, levels[i], plusMinusIcon, iconVal, selInd == i)
    '''
    # g.trace('skip', skip, 'count', count)
    Npos = len(self.positions)
    if count is None:
        count = Npos
    ( positions, nodes, attrs, levels, gnx2pos, parPos,
      expanded, marked, selPos) = self.ivars()
    #
    selInd = self.selectedIndex
    i = 1
    while count &gt; 0 and i &lt; Npos:
        gnx = nodes[i]
        pos = positions[i]
        h, b, parents, hasChildren, treeSize = attrs[gnx]
        exp = (pos in expanded)
        if skip &gt; 0:
            skip -= 1
        else:
            # There is one less line to be drawn.
            count -= 1
            # Compute the iconVal for the icon box.
            iconVal = 1 if b else 0
            iconVal += 2 if gnx in marked else 0
            iconVal += 4 if len(parents) &gt; 1 else 0
            # Compute the +- icon if the node has children.
            if hasChildren:
                plusMinusIcon = 'minus' if exp else 'plus'
            else:
                plusMinusIcon = 'none'
            # Yield a tuple describing the line to be drawn.
            yield pos, gnx, h, levels[i], plusMinusIcon, iconVal, selInd == i
        if hasChildren and exp:
            i += 1
        else:
            i += treeSize
</t>
<t tx="vitalije.20180516131800.1">def topIndex_write(a, b, c):
    return draw_tree(tree, ltm)

def show_sel():
    sel = ltm.visible_positions.index(ltm.selectedPosition) + 1
    nr = rows_count(24)
    i = topIndex.get()
    if nr + i &lt; sel or i &gt; sel - 1:
        topIndex.set(max(0, sel - nr // 2))
    G.app.after(30, show_sel)

show_sel()
</t>
<t tx="vitalije.20180516132431.1">def promote(self, pos):
    '''Makes following siblings of pos, children of pos'''
    g.trace('*****')
    # ( positions, nodes, attrs, levels, gnx2pos, parPos,
      # expanded, marked, selPos) = self.ivars()
    attrs = self.attrs
    expanded = self.expanded
    gnx2pos = self.gnx2pos
    levels = self.levels
    nodes = self.nodes
    parPos = self.parPos
    positions = self.positions
    # 
    # node at position pos
    i = positions.index(pos)
    gnx = nodes[i]
    lev0 = levels[i]

    # parent node
    pp = parPos[i]
    pi = positions.index(pp)
    pgnx = nodes[pi]
    psz = attrs[pgnx][4]

    # index of node after tree
    after = pi + psz

    # remember originial size
    oldsize = attrs[gnx][4]
    A = i + oldsize

    # check danger clones
    if gnx in nodes[A:after]:
        print('warning node can not be in its own subtree')
        return

    # adjust size of this node
    attrs[gnx][4] = oldsize + after - A
    @others

    # finally to show indented nodes
    expanded.add(pos)

</t>
<t tx="vitalije.20180516141710.1">def promote_children(self, pos):
    '''Turns children to siblings of pos'''
    g.trace('*****')
    # ( positions, nodes, attrs, levels, gnx2pos, parPos,
      # expanded, marked, selPos) = self.ivars()
    attrs = self.attrs
    gnx2pos = self.gnx2pos
    levels = self.levels
    nodes = self.nodes
    parPos = self.parPos
    positions = self.positions

    # this node
    i = positions.index(pos)
    gnx = nodes[i]

    # parent node
    pp = parPos[i]
    pi = positions.index(pp)
    pgnx = nodes[pi]
    pchn = attrs[pgnx][3]

    h, b, mps, chn, sz0 = attrs[gnx]
    # node after
    B = i + sz0

    @others
</t>
<t tx="vitalije.20180517160150.1">j = A # iterator of following siblings
while j &lt; after:
    cgnx = nodes[j]
    parPos[j] = pos
    h, b, ps, chn, sz = attrs[cgnx]

    # let's replace pgnx with gnx in parents
    ps[ps.index(pgnx)] = gnx

    # append to children of this node
    attrs[gnx][3].append(cgnx)

    # remove from children of pgnx
    attrs[pgnx][3].remove(cgnx)

    # next sibling
    j += sz

levels[A:after] = [x + 1 for x in levels[A:after]]
</t>
<t tx="vitalije.20180517160237.1"># now we have already made all following siblings 
# children of this node (gnx at position pos)
# we need to insert the same nodes to
# outline after each clone in the outline
allpos = [x for x in gnx2pos[gnx] if x != pos]
if not allpos: return expanded.add(pos)

# prepare data for insertion
sibgnx = nodes[A:after]
siblev = [x-lev0  for x in levels[A:after]]

# for parPosIter we need level 0
levs = [0] + siblev

while allpos:
    ipos = allpos.pop()
    ii = positions.index(ipos)

    # old index of after tree
    jj = ii + oldsize

    # insert in nodes
    nodes[jj:jj] = sibgnx

    # insert levels adjusted by level of this clone
    lev1 = levels[ii]
    levels[jj:jj] = [x + lev1 for x in siblev]

    # we need new positions for inserted nodes
    npos = [random.random() for x in siblev]
    positions[jj:jj] = npos

    # insert parPos
    npos.insert(0, ipos)
    ppos = list(parPosIter(npos, levs))
    parPos[jj:jj] = ppos[1:]

    # update gnx2pos for each new position
    for p1,x in zip(npos[1:], sibgnx):
        gnx2pos[x].append(p1)
</t>
<t tx="vitalije.20180517160615.1">def updateSize(x):
    d = attrs[x]
    d[4] += after - A
    for x1 in d[2]:
        updateSize(x1)

allparents = attrs[gnx][2][:]
allparents.remove(pgnx) # for one of them we have already updated size
for x in allparents:
    updateSize(x)
</t>
<t tx="vitalije.20180517171517.1"># reduce levels
levels[i+1:B] = [x - 1 for x in levels[i + 1:B]]
</t>
<t tx="vitalije.20180517171551.1">j = i + 1
while j &lt; B:
    cgnx = nodes[j]
    h, b, ps, gchn, sz = attrs[cgnx]

    # replace parent with grandparent
    ps[ps.index(gnx)] = pgnx

    # remove from children of this node
    chn.remove(cgnx)

    # append to grandparent's children
    pchn.append(cgnx)

    # adjust parPos
    parPos[j] = pp

    j += sz # next child
</t>
<t tx="vitalije.20180517171628.1">attrs[gnx][4] = 1
</t>
<t tx="vitalije.20180517171705.1">if len(mps) == 1:
    # there is no standalone clones
    return

def updateSize(x):
    d = attrs[x]
    d[4] = d[4] - sz0 + 1
    for x1 in d[2]:
        updateSize(x1)

for px in gnx2pos[gnx]:
    i1 = positions.index(px)
    if px != pos:
        # this is another clone
        for j in range(i1 + 1, i1 + sz0):
            cgnx = nodes[j]
            gnx2pos[cgnx].remove(positions[j])
        pi1 = positions.index(parPos[i1])
        updateSize(nodes[pi1])
        del positions[i1+1:i1+sz0]
        del levels[i1+1:i1+sz0]
        del nodes[i1+1:i1+sz0]
        del parPos[i1+1:i1+sz0]
</t>
<t tx="vitalije.20180517172602.1">def indent_node(self, pos):
    '''Moves right node at position pos'''
    g.trace('*****')
    # ( positions, nodes, attrs, levels, gnx2pos, parPos,
      # expanded, marked, selPos) = self.ivars()
    attrs = self.attrs
    expanded = self.expanded
    gnx2pos = self.gnx2pos
    levels = self.levels
    nodes = self.nodes
    parPos = self.parPos
    positions = self.positions

    # this node
    i = positions.index(pos)
    if levels[i-1] == levels[i] - 1:
        # if there is no previous siblings node
        # can't be moved right
        return
    gnx = nodes[i]
    lev0 = levels[i]

    # parent node
    pp = parPos[i]
    pi = positions.index(pp)
    pgnx = nodes[pi]

    h, b, mps, chn, sz0 = attrs[gnx]
    # node after
    B = i + sz0


    j = A = pi + 1
    while j &lt; i:
        A = j
        j += attrs[nodes[j]][4]
    # in A is index of new parent
    npgnx = nodes[A]
    if npgnx == gnx:
        print('Warning can not move node to its own subtree')
        return
    @others

    # finally let's make node visible
    expanded.add(positions[A])

</t>
<t tx="vitalije.20180517172756.1">levels[i:B] = [x+1 for x in levels[i:B]]
</t>
<t tx="vitalije.20180517172946.1">
mps[mps.index(pgnx)] = npgnx
parPos[i] = positions[A]

# remove from children of old parent
attrs[pgnx][3].remove(gnx)

# add to new parent's children
attrs[npgnx][3].append(gnx)
</t>
<t tx="vitalije.20180517173423.1"></t>
<t tx="vitalije.20180517181545.1">oldSize = attrs[npgnx][4]

def updateSize(x):
    d = attrs[x]
    d[4] += sz0
    for x1 in d[2]:
        updateSize(x1)

attrs[npgnx][4] += sz0
xx = attrs[npgnx][2][:]
xx.remove(pgnx)
for x in xx:
    updateSize(x)
</t>
<t tx="vitalije.20180517181729.1">pxA = positions[A]

levs = [x-lev0 for x in levels[i:B]]
nnds = nodes[i:B]
</t>
<t tx="vitalije.20180517181737.1">for px in gnx2pos[npgnx]:
    if px == pxA: continue
    i1 = positions.index(px)

    jj = i1 + oldSize
    lev1 = levels[i1]
    levels[jj:jj] = [x + lev1 for x in levs]
    npos = [random.random() for x in levs]
    positions[jj:jj] = npos
    parPos[jj:jj] = list(parPosIter([px] + npos, [0] + levs))[1:]
    nodes[jj:jj] = nnds
    for p, x in zip(npos, nnds):
        gnx2pos[x].append(p)
</t>
<t tx="vitalije.20180518115534.1">def draw_loop():
    '''
    Update or add items: return the index of the last drawn row.
    count: the number of rows to draw.
    items: all the items in the canvas.
    '''
    i = 1
        # The global row.
        # Each row consists of 3 items: the checkbox, icon and text.
    for j, dd in enumerate(ltm.display_items(G.topIndex.get(), count)):
        p, gnx, h, lev, pm, iconVal, sel = dd
            # The tuples returned from display_items.
        pmicon = getattr(G.icons, pm)
        #
        # Update the counts &amp; offests.
        i = j * 3 + 1
        x = lev * LW - 20
        y = j * HR + HR + 2
        #
        # Set the color
        if sel:
            canv.coords(items[0], 0, y - HR/2 - 2, canv.winfo_width(), y + HR/2 + 2)
            fg = '#000000'
        else:
            fg = '#a0a070'
        if i + 2 &lt; len(items):
            # Reconfigure existing items
            if pmicon:
                canv.itemconfigure(items[i], image=pmicon)
                canv.coords(items[i], x, y)
            else:
                canv.coords(items[i], -200, y)
            canv.itemconfigure(items[i + 1], image=G.boxes[iconVal])
            canv.coords(items[i + 1], x + 20, y)
            canv.itemconfigure(items[i + 2], text=h, fill=fg)
            canv.coords(items[i + 2], x + 40, y)
        else:
            # Add 3 more items to canvas.
            items.append(canv.create_image(x, y, image=pmicon))
            items.append(canv.create_image(x + 20, y, image=G.boxes[iconVal]))
            items.append(canv.create_text(x + 40, y, text=h, anchor="w", fill=fg))
            # Bind clicks to click handlers.
            canv.tag_bind(items[i], '&lt;Button-1&gt;', click_pmicon(j), add=False)
            canv.tag_bind(items[i + 1], '&lt;Button-1&gt;', click_h(j), add=False)
            canv.tag_bind(items[i + 2], '&lt;Button-1&gt;', click_h(j), add=False)
    # Hide any extra item on canvas 
    for item in items[i + 3:]:
        canv.coords(item, 0, -200)
</t>
</tnodes>
</leo_file>
